#include <iostream>
#include <iomanip>
#include <windows.h>
#include <fstream>
#include <string>
#include <conio.h>
#include <codecvt>

using namespace std;

struct User {
    string username;
    string password;
};

void usersFunctional(User& currentUserLogin, wstring**& lines, int& lineCount);
void ShowUsers(int choice);
void printFoundTours(wstring** lines, int lineCount, int& x, int& y, int ifcolor, int index);
void DeleteChoosenByCriteriaTour();
void printCentered(const string& text, int numLines, int x, int y);
void Findtours(wstring**& lines, int& lineCount, int choice);
void split(const wstring& input, wstring& storedCityOfDeparture, wstring& storedCountryOfArrival, wstring& storedResortCity, wstring& storedStartDate, wstring& storedEndDate, wstring& storedMaxCost);
bool isDateInRange(wstring startDate, wstring storedStartDate, wstring storedEndDate);
void FindToDeletIrrelevant();
wstring splitEndDate(const wstring line);
void Deleting(const wstring& lineToDelete, const string filename);
wstring stringToWstring(const string& str);
string wstringToString(const wstring& wstr);
void DeleteChoosenUser(int role, string userlogin);
void changeAccountData(const string filename, const string userlogin, const string userpassword, int field, User& currentUser);
void addNewData(const string filename, string userloginandpassword);
string getFieldsOfNewUser();
void addNewTour(const string filename, wstring addedline);
wstring getFieldsOfNewTour();
void addFoundToursInArray(wstring**& lines, int& lineCount, const wstring& line);
void shakerSort(wstring**& lines, int start, int lineCount, int index, int cresing);
void ifSort(wstring**& lines, int lineCount, int& userchoice);
void Exit(User& currentUser);
void ShowTours(wstring**& lines, int& lineCount);
void saveTour(string currentlogin, int choice, wstring**& lines, string filename);
void showSavedTours(string userlogin, string filename);
void editTours(wstring**& lines, int lineCount, string filename, int choice);
void showUsersSavedTours(int& x, int& y, string filename);
void deleteSavedTours(string username);
void editSavedTours(string olduserlogin, string newuserlogin);
void deleteChoosenSavedTour(int tournum, string userlogin);
bool isLastMinTour(int index, wstring**& lines, int role);
void deletingSaveToursAfterDeletingMainTour(wstring deletingtour);
void adminFunctional(User& currentUserlogin, wstring**& lines, int& lineCount);
void DeleteChoosenByNumTour(wstring**& lines, int numofdeleting);
int partition(wstring**& lines, int low, int high, int cresing, int index);
void quickSort(wstring**& lines, int low, int high, int cresing, int index);
int binarySearch(wstring** lines, int left, int lineCount, wstring foodtype);


bool isUsernameUnique(const string& filename, const string& username) {
    ifstream infile(filename);
    if (!infile.is_open()) {
        cerr << "Ошибка открытия файла!" << endl;
        exit(1);
    }

    string storedUsername, storedPassword;
    while (infile >> storedUsername >> storedPassword) {
        if (storedUsername == username) {
            return false;
        }
    }
    return true;
}

// Функция проверки логина и пароля на содержание пробелов
bool CorrectLogin(const string& login) {
    int pos = login.find(" ");
    if (pos == -1 ) {
        return false;
    }
    else {
        return true;
    }
}

bool registerUser(const string& filename, User& currentUserLogin) {//сделать центрирование текста
    ofstream file(filename, ios::app);
    if (!file.is_open()) {
        cerr << "Ошибка открытия файла!" << endl;
        exit(1);
    }

    printCentered("РЕГИСТРАЦИЯ\nВведите логин: ", 2, 0, 0);
    string username;
    getline(cin, username);
    getline(cin, username);
    bool unique = isUsernameUnique(filename, username), containpt = CorrectLogin(username);

    while (!unique || containpt || username.empty()) {
        if (!unique) {
            printCentered("Пользователь с таким логином уже существует. Пожалуйста, выберите другой логин: ", 1, 0, 0);
        }
        else if (containpt) {
            printCentered("Логин не может содержать пробелы. Пожалуйста, введите еще раз: ", 1, 0, 0);

        }
        else {
            printCentered("Логин некорректен, пожалуйста, введите еще раз: ", 1, 0, 0);
        }
        getline(cin, username);
        unique = isUsernameUnique(filename, username);
        containpt = CorrectLogin(username);
    }

    printCentered("РЕГИСТРАЦИЯ\nВведите пароль: ", 2, 0, 0);
    string password;
    cin >> password;

    file << username << " " << password << endl;
    printCentered(username + ", Вы зарегистрированы. Теперь войдите в систему.", 1, 0, 0);
    Sleep(2000);
    currentUserLogin.username = username;
    currentUserLogin.password = password;
    file.close();
    return true;
}

bool loginUser(const string& filename, User& currentUserLogin) {
    ifstream infile(filename);
    if (!infile.is_open()) {
        cerr << "Ошибка открытия файла!" << endl;
        exit(1);
    }

    int attempts = 3;
    bool found = false;

    while (attempts > 0 && !found) {
        string username, password;
        printCentered("АВТОРИЗАЦИЯ\nВведите логин: ", 2, 0, 0);
        cin >> username;
        printCentered("АВТОРИЗАЦИЯ\nВведите пароль: ", 2, 0, 0);
        cin >> password;

        string storedUsername, storedPassword;

        while (infile >> storedUsername >> storedPassword) {
            if (storedUsername == username && storedPassword == password) {
                found = true;
                currentUserLogin.username = username;
                currentUserLogin.password = password;
                break;
            }
        }

        if (found) {
            printCentered("Вы успешно вошли в систему.", 1, 0, 0);
            Sleep(1000);
            return true;
        }
        else {
            attempts--;
            if (attempts > 0) {
                printCentered("Неправильный логин или пароль. Попробуйте еще раз.", 1, 0, 0);
                Sleep(2000);
            }
        }
        infile.clear();
        infile.seekg(0, ios::beg);
    }

    printCentered("Вы исчерпали все попытки входа в систему.", 1, 0, 0);
    Sleep(700);
    return false;
}

// Функция для входа администратора
bool adminLogin(const string& adminPasswordFile) {
    ifstream infile(adminPasswordFile);
    if (!infile.is_open()) {
        cerr << "Ошибка открытия файла!" << endl;
        exit(1);
    }

    int attempts = 3;
    bool found = false;

    while (attempts > 0 && !found) {
        string adminPassword;
        printCentered("АВТОРИЗАЦИЯ\nВведите пароль администратора: ", 2, 0, 0);
        cin >> adminPassword;

        string storedPassword;
        infile >> storedPassword;

        if (adminPassword == storedPassword) {
            printCentered("Вы успешно вошли как администратор.", 1, 0, 0);
            found = true;
            Sleep(1000);
        }
        else {
            attempts--;
            if (attempts > 0) {
                printCentered("Неправильный пароль администратора. Попробуйте еще раз.", 1, 0, 0);
                Sleep(1000);
            }
        }

        infile.clear();
        infile.seekg(0, ios::beg); // cброс в начало файла
    }

    if (attempts == 0) {
        printCentered("Вы исчерпали все попытки входа в систему.", 1, 0, 0);
    }
    infile.close();
    return found;
}

void printCentered(const string& text, int numLines, int x, int y)
{
    if (x == 0 && y == 0) {
        system("cls");
    }

    CONSOLE_SCREEN_BUFFER_INFO csbi;
    GetConsoleScreenBufferInfo(GetStdHandle(STD_OUTPUT_HANDLE), &csbi);

    int consoleWidth = csbi.srWindow.Right - csbi.srWindow.Left + 1;
    int consoleHeight = csbi.srWindow.Bottom - csbi.srWindow.Top + 1;
    int posY, posX;
    int totalTextLines = numLines;
    if (y == 0) {
        posY = (consoleHeight - totalTextLines) / 2;
    }
    else {
        posY = y + 2;
    }

    int startPos = 0;
    for (int i = 0; i < totalTextLines; i++) {
        string line;
        int found = text.find('\n', startPos);
        if (found != string::npos) {
            line = text.substr(startPos, found - startPos);
            startPos = found + 1;
        }
        else {
            line = text.substr(startPos);
        }
        if (x == 0) {
            if (i == 0) {
                posX = (consoleWidth - line.length()) / 2;
            }
        }
        else {
            posX = x;
        }

        COORD cursorPos = { posX, posY + i };
        SetConsoleCursorPosition(GetStdHandle(STD_OUTPUT_HANDLE), cursorPos);
        cout << line;
    }
}

void isSave(User& currentUserlogin, wstring**& lines, int& lineCount) {

    int x = 0, y = 0, userchoice;
    while (true) {
        printCentered("НАЙДЕННЫЕ ТУРЫ\n", lineCount + 2, 0, 0);
        printFoundTours(lines, lineCount, x, y, -1, -1);

        printCentered("Введите номер тура, который хотите сохранить: ", 1, x, y);
        cin >> userchoice;
        if (userchoice > lineCount) {
            printCentered("Тура под таким номером не существует. Выберете еще раз.", 1, 0, 0);
            Sleep(1000);
        }
        else {
            break;
        }
    }
    saveTour(currentUserlogin.username, userchoice - 1, lines, "savedtour.txt");// в вызове отнимать 1 чтобы совпадала нумирация в спискке и в массиве
}

void usersFunctional(User& currentUserlogin, wstring**& lines, int& lineCount) {
    int x = 0, y = 0;

    while (currentUserlogin.username != "" && currentUserlogin.password != "") {
        printCentered("ГЛАВНОЕ МЕНЮ\n1.Найти тур\n2.Просмотреть сохраненные туры\n3.Изменить пароль\n4.Изменить логин\n5.Удалить учетную запись\n6.Выйти из учетной записи\nВыберите действие: ", 8, 0, 0);
        int userchoice, userchoosentour;
        wstring userchoicesort;
        bool iscontinue = true;
        cin >> userchoice;
        switch (userchoice)
        {
        case 1:
            lines = nullptr;
            lineCount = 0;
            Findtours(lines, lineCount, 1); // посл поиска сортировка, сохр выбранных  туров

            if (lineCount == 0) {
                printCentered("Туров с таким набором критериев нет", 1, 0, 0);
            }
            else {
                printCentered("НАЙДЕННЫЕ ТУРЫ\n", lineCount + 2, 0, 0);
                printFoundTours(lines, lineCount, x, y, -1, -1);
                cout << "\n\n\n";
                system("pause");
                while (iscontinue) {
                    printCentered("введите 1, если желаете сохранить какой-то тур в своей учетной записи,\nВведите 2, если хотите отсортировать туры\nВведите 0, если необходимо вернуться в главное меню\nВыберете действие: ", 4, 0, 0);
                    cin >> userchoice;
                    switch (userchoice)
                    {
                    case 1:
                        while (true) {
                            printCentered("НАЙДЕННЫЕ ТУРЫ\n", lineCount + 2, 0, 0);
                            x = 0, y = 0;
                            printFoundTours(lines, lineCount, x, y, -1, -1);

                            printCentered("Введите номер тура, который хотите сохранить: ", 1, x, y);
                            cin >> userchoice;
                            if (userchoice > lineCount) {
                                printCentered("Тура под таким номером не существует. Выберете еще раз.", 1, 0, 0);
                                Sleep(1000);
                            }
                            else {
                                break;
                            }
                        }
                        saveTour(currentUserlogin.username, userchoice - 1, lines, "savedtour.txt");// в вызове отнимать 1 чтобы совпадала нумирация в спискке и в массиве
                        cout << "\n\n\n";
                        Sleep(1000);
                        break;
                    case 2:
                        while (true) {
                            userchoice = 0;
                            ifSort(lines, lineCount, userchoice);

                            while (true) {
                                printCentered("ОТСОРТИРОВАННЫЕ ТУРЫ\n", lineCount + 2, 0, 0);
                                int x = 0, y = 0;                                
                                printFoundTours(lines, lineCount, x, y, 1, userchoice-1);
                                printCentered("Желаете ли сохранить какой-нибудь тур (да/нет): ", 1, x, y);
                                wcin >> userchoicesort;
                                if (userchoicesort == L"да") {
                                    while (true) {
                                        printCentered("ОТСОРТИРОВАННЫЕ ТУРЫ\n", lineCount + 2, 0, 0);
                                        x = 0, y = 0;
                                        printFoundTours(lines, lineCount, x, y, 1, userchoice-1);
                                        printCentered("Введите номер тура, который хотите сохранить: ", 1, x, y);
                                        cin >> userchoosentour;
                                        if (userchoosentour > lineCount) {
                                            printCentered("Тура под таким номером не существует. Выберете еще раз.", 1, 0, 0);
                                            Sleep(1000);
                                        }
                                        else {
                                            break;
                                        }
                                    }
                                    saveTour(currentUserlogin.username, userchoosentour - 1, lines, "savedtour.txt");
                                    Sleep(1000);
                                }
                                else if (userchoicesort != L"да" && userchoicesort != L"нет") {
                                    printCentered("Введено неверно. Повторите действия.", 1, 0, 0);
                                    Sleep(1000);
                                }
                                else if (userchoicesort != L"да") {
                                    break;
                                }
                            }

                            while (true) {
                                printCentered("ОТСОРТИРОВАННЫЕ ТУРЫ\n", lineCount + 2, 0, 0);
                                int x = 0, y = 0;
                                printFoundTours(lines, lineCount, x, y, -1, -1);

                                printCentered("Желаете ли произвести другую сортировку (да/нет): ", 1, x, y);
                                wcin >> userchoicesort;
                                if (userchoicesort != L"да" && userchoicesort != L"нет") {
                                    printCentered("Введено неверно. Повторите действия.", 1, 0, 0);
                                    Sleep(1000);
                                }
                                else {
                                    break;
                                }
                            }

                            if (userchoicesort == L"нет") {
                                break;
                            }
                        }                         
                        break;
                    case 0:
                        iscontinue = false;
                        break;
                    default:
                        printCentered("Такого действия не существует. Выберете другое: ", 1, 0, 0);
                        break;
                    }
                }
            }
            break;
        case 2:
            // просмотреть сохраненные туры
            showSavedTours(currentUserlogin.username, "savedtour.txt");
            break;
        case 3:
            //изменить пароль
            changeAccountData("users.txt", currentUserlogin.username, currentUserlogin.password, 2, currentUserlogin);
            break;
        case 4:
            //измеить логин
            changeAccountData("users.txt", currentUserlogin.username, currentUserlogin.password, 1, currentUserlogin);
            break;
        case 5:
            //удаление учетной записи
            DeleteChoosenUser(1, currentUserlogin.username);
            // ОЧИЩАТЬ ФАЙЛ СОХРАНЕННЫХ ТУРОВ!!!!!!!!!!!!!!!!
            break;
        case 6:
            //выйти из учет записи
            Exit(currentUserlogin);
            break;
        default:
            printCentered("Действие выбрано неверно. Выполните ввод заново", 1, 0, 0);
            break;
        }
        Sleep(1000);
    }
};

void adminFunctional(User& currentUserlogin, wstring**& lines, int& lineCount) {
    //меню админа (измениь пароль, просмотреть пользователей, просмотреть созраненные туры пользователя, )
    int adminchoice, x=0,y=0;
    while (true) {
        lines = nullptr;
        lineCount = 0;
        printCentered("ГЛАВНОЕ МЕНЮ\n1.Редактировать туры\n2.Удалить туры\n3.Добавить туры\n4.Найти туры\n5.Просмотреть пользователей\n6.Удалить пользователя\n7.Добавить пользователя\n8.Просмотреть сохраненные пользователем туры\n9.Просмотреть все туры\n10.Выйти из учетной записи\nВыберите действие: ", 12, 0, 0);
        cin >> adminchoice;
        switch (adminchoice) {
        case 1:
            //редактировать туры
            ShowTours(lines, lineCount);
            printFoundTours(lines, lineCount , x, y, -1, -1);
            printCentered("\n\nВведите номер, редактируемого тура: ", 3, x, y);
            cin >> adminchoice;
            editTours(lines, lineCount, "toursmain1.txt", adminchoice);
            break;
        case 2:
            printCentered("1. Удалить неактуальные туры\n2. Удалить один выбранный тур\n3. Удалить туры по некоторым критериям\nВыберите действие: ", 4, 0, 0);
            int deletechoice;
            cin >> deletechoice;
            while (deletechoice != 0) {
                switch (deletechoice)
                {
                case 1:
                    FindToDeletIrrelevant();
                    deletechoice = 0;
                    break;
                case 2:
                    while (true) {
                        lines = nullptr, lineCount = 0;
                        ShowTours(lines, lineCount);
                        printFoundTours(lines, lineCount, x, y, -1, -1);
                        printCentered("\n\nВведите номер, удаляемого тура: ", 3, x, y);
                        cin >> adminchoice;
                        if (adminchoice <= 0 || adminchoice > lineCount) {
                            printCentered("Тура под таким номером нет. Повторите действие.", 1, 0, 0);
                            Sleep(2000);
                        }
                        else {
                            break;
                        }
                    }
                    DeleteChoosenByNumTour(lines, adminchoice - 1);
                    deletechoice = 0;
                    break;
                case 3:
                    DeleteChoosenByCriteriaTour();
                    deletechoice = 0;
                    break;
                default:
                    printCentered("Неправильный выбор. Повторите действие или введите 0 для возвращения в главное меню", 1, 0, 0);
                    Sleep(2000);
                    printCentered("1.Удалить неактуальные туры\n2.Удалить один выбранный тур\n3. Удалить туры по некоторым критериям\nВыберите действие: ", 4, 0, 0);
                    cin >> deletechoice;
                    break;
                }
            }
            break;
        case 3:
            //добавить тур
            addNewTour("toursmain1.txt", getFieldsOfNewTour());
            break;
        case 4:
            // найти туры
            Findtours(lines, lineCount, 1);
            if (lineCount == 0) {
                printCentered("Туров с таким набором критериев нет", 1, 0, 0);
            }
            else {
                printCentered("НАЙДЕННЫЕ ТУРЫ\n", lineCount + 2, 0, 0);
                printFoundTours(lines, lineCount, x, y, -1, -1);
                cout << "\n\n\n";
                system("pause");
            }
            break;
        case 5:
            // показать польз
            ShowUsers(0);
            break;
        case 6:
            // удалить польз
            DeleteChoosenUser(0, currentUserlogin.username);
            break;
        case 7:
            // добавить польз
            addNewData("users.txt", getFieldsOfNewUser());
            break;
        case 8:
            // показать сохраненнве тур
            showUsersSavedTours(x, y, "savedtour.txt");
            break;
        case 9:
            // все туры
            ShowTours(lines, lineCount);
            break;
        case 10:
            // выход
            return;
            break;
        default:
            printCentered("Действие выбрано неправильно. Повторите ввод.", 1, 0, 0);
            Sleep(2000);
            break;
        }
        cout << "\n\n\n";
        system("pause");
    }
}

int main() {
    setlocale(LC_ALL, "Ru");
    SetConsoleCP(1251);
    SetConsoleOutputCP(1251);
    ShowWindow(GetConsoleWindow(), SW_MAXIMIZE);
    printCentered("ДОБРО ПОЖАЛОВАТЬ В ПРОГРАММУ ПОДБОРА ТУРИСТИЧЕСКИХ ПУТЕВОК", 1, 0, 0);
    Sleep(2500);

    bool isExit = true;

    while (isExit) {

        printCentered("НАЧАЛЬНОЕ МЕНЮ\n1.Регистрация\n2.Вход\n3.Вход для администратора\n4.Выйти\nВыберите действие: ", 6, 0, 0);

        User currentUserlogin;
        bool entered = false;
        int choice;

        wstring** lines = nullptr;
        int lineCount = 0;

        cin >> choice;
        system("cls");
        switch (choice) {
        case 1:
            registerUser("users.txt", currentUserlogin);
        case 2:
            entered = loginUser("users.txt", currentUserlogin);
            break;
        case 3:
            entered = adminLogin("admin.txt");
            break;
        case 4:
            printCentered("ДО СВИДАНИЯ!", 1, 0, 0);
            isExit = false;
            break;
        default:
            printCentered("Неправильный выбор. Попробуйте вновь.", 1, 0, 0);
            break;
        }

        if (!entered) {
            exit(0);
        }

        if (choice == 1 || choice == 2) {
            usersFunctional(currentUserlogin, lines, lineCount);
        }
        else if (choice == 3) {
            adminFunctional(currentUserlogin, lines, lineCount);
        }
    }
}

void deleteSavedTours(string username) {
    wifstream file("savedtour.txt", ios::app);
    file.imbue(locale(file.getloc(), new codecvt_utf8<wchar_t>));
    wstring line;
    while (getline(file, line)) {
        wstring login = line.substr(0, line.find(L":"));
        if (line.substr(0, line.find(L":")) == stringToWstring(username)) {
            Deleting(line, "savedtour.txt");
        }
    }

}

void DeleteChoosenByNumTour(wstring**& lines, int numofdeleting) {
    wifstream file("toursmain1.txt", ios::app);
    file.imbue(locale(file.getloc(), new codecvt_utf8<wchar_t>));
    wstring line, deletingtour;
    for (int i = 0; i < 15; i++) {
        deletingtour += lines[numofdeleting][i] + L"/";
    }
    while (getline(file, line)) {
        if (line == deletingtour) {
            Deleting(line, "toursmain1.txt");
            printCentered("Тур успешно удален.", 1, 0, 0);
            Sleep(1000);
            break;
        }
    }
}

void showUsersSavedTours(int& x, int& y, string filename) {
    int count = 0;
    wstring line, savedtours = L"";
    string username, skip = "";
    wifstream file(filename, ios::app);
    file.imbue(locale(file.getloc(), new codecvt_utf8<wchar_t>));
    ShowUsers(1);
    cin >> username;
    while (isUsernameUnique("users.txt", username)) {
        printCentered("Пользователя " + username + " нет в системе. Повторите действие.", 1, 0, 0);
        Sleep(2000);
        ShowUsers(1);
        cin >> username;
    }
    while (getline(file, line)) {
        if (line.substr(0, line.find(L":")) == stringToWstring(username)) {
            count++;
            savedtours += line.substr(line.find(L":") + 2, line.size() - line.find(L":")) + L"\n";
        }
    }
    
    for (int i = 0; i < savedtours.length(); i++) {
        if (savedtours[i] == L'/') {
            savedtours[i] = L' ';
        }
    }

    for (int i = 0; i < count; i++) {
        skip += "\n";
    }
    if (count == 0) {
        printCentered("У пользователя " + username + " нет сохраненных туров", 1, 0, 0);
    }
    else {
        printCentered("СОХРАНЕННЫЕ ТУРЫ ПОЛЬЗОВАТЕЛЯ " + username + skip, count + 2, 0, 0);
        CONSOLE_SCREEN_BUFFER_INFO csbi;
        GetConsoleScreenBufferInfo(GetStdHandle(STD_OUTPUT_HANDLE), &csbi);
        int consoleWidth = csbi.srWindow.Right - csbi.srWindow.Left + 1;
        int consoleHeight = csbi.srWindow.Bottom - csbi.srWindow.Top + 1;
        int posY = (consoleHeight - count) / 2;
        int posX = (consoleWidth - (savedtours.substr(0, savedtours.find(L"\n"))).length() - 3) / 2;
        for (int i = 0; i < count; ++i) {
            HANDLE consoleHandle = GetStdHandle(STD_OUTPUT_HANDLE);
            COORD cursorPos = { posX, posY + i };
            SetConsoleCursorPosition(consoleHandle, cursorPos);
            cout << i + 1 << ". ";
            wcout << savedtours.substr(0, savedtours.find(L"\n"));
            savedtours = savedtours.erase(0, savedtours.find(L"\n") + 1);
        }
    }
}

void ShowTours(wstring**& lines, int& lineCount) {
    Findtours(lines, lineCount, 0);
    string skip;
    for (int i = 0; i < lineCount; i++) {
        skip += "\n";
    }
    printCentered("ВСЕ ТУРЫ, ИМЕЮЩИЕСЯ В СИСТЕМЕ" + skip, lineCount + 2, 0, 0);
    int x = 0, y = 0;
    printFoundTours(lines, lineCount, x, y, -1, -1);

}

void saveTour(string currentlogin, int choice, wstring**& lines, string filename) {
    wofstream file(filename, ios::app);
    wifstream chek(filename, ios::app);
    file.imbue(locale(file.getloc(), new codecvt_utf8<wchar_t>));
    chek.imbue(locale(chek.getloc(), new codecvt_utf8<wchar_t>));

    if (!file.is_open()) {
        wcerr << "Ошибка открытия файла!" << endl;
        exit(1);
    }
    else {
        wstring string, line;
        bool issafe = false;
        /*
        if (isLastMinTour(lines[choice][4])) {
            lines[choice][5] = (to_wstring(static_cast<int>(round(stod(lines[i][5]) - stod(lines[i][5]) * 0.3))));
        }*/
        for (int i = 0; i < 15; i++) {
            string += lines[choice][i] + L"/";
        }
        while (getline(chek, line)) {
            if (line == stringToWstring(currentlogin) + L": " + string) {
                issafe = true;
                break;
            }
        }
        if (issafe) {
            printCentered("Тур был ранее сохранен.", 1, 0, 0);
        }
        else {
            file << stringToWstring(currentlogin) << L": " << string + L"\n";
            printCentered("Тур успешно сохранен.", 1, 0, 0);
        }
    }
}

void showSavedTours(string userlogin, string filename) {
    wifstream file(filename, ios::app);
    file.imbue(locale(file.getloc(), new codecvt_utf8<wchar_t>));
    wstring line, savedtours, tempsavedtours;
    int count = 0, userchoice;
    while (getline(file, line)) {
        if (line.substr(0, line.find(L":", 0)) == stringToWstring(userlogin)) {
            count++;
            savedtours += line.substr(line.find(L":", 0) + 2, line.length() - line.find(L":", 0)) + L"\n";
        }
    }

    for (int i = 0; i < savedtours.length(); i++) {
        if (savedtours[i] == L'/') {
            savedtours[i] = L' ';
        }
    }

    if (count == 0) {
        printCentered("У вас нет сохраненных туров", 1, 0, 0);
    }
    else {
        while (true) {
            tempsavedtours = savedtours;
            string skip = "";
            for (int i = 0; i < count; i++) {
                skip += "\n";
            }
            printCentered("ВАШИ СОХРАНЕННЫЕ ТУРЫ"+ skip, count+1, 0, 0);   
            CONSOLE_SCREEN_BUFFER_INFO csbi;
            GetConsoleScreenBufferInfo(GetStdHandle(STD_OUTPUT_HANDLE), &csbi);
            int consoleWidth = csbi.srWindow.Right - csbi.srWindow.Left + 1;
            int consoleHeight = csbi.srWindow.Bottom - csbi.srWindow.Top + 1;


            string criteria1 = "|   город   | страна |  город  |   первое  | последнее |стоимость|отель|рейтинг|  тип  |линия | тип | наличие |необходимость|    тип    |\n";
            string criteria2 = "|отправления|прибытия|курортный|отправление|отправление|         |     | отеля |питания|берега|пляжа|трансфера|    визы     |перемещения|\n";

            int posY = 1 + (consoleHeight - count - 1) / 2;

            int posX = (consoleWidth - criteria1.length()) / 2;

            HANDLE consoleHandle = GetStdHandle(STD_OUTPUT_HANDLE);
            COORD cursorPos = { posX, posY };
            SetConsoleCursorPosition(consoleHandle, cursorPos);
            cout << criteria1;

            cursorPos.Y = posY + 1;
            SetConsoleCursorPosition(consoleHandle, cursorPos);
            cout << criteria2;
            posY += 3;
            posX = (consoleWidth - (savedtours.substr(0, savedtours.find(L"\n"))).length() - 3) / 2;
            for (int i = 0; i < count; ++i) {
                HANDLE consoleHandle = GetStdHandle(STD_OUTPUT_HANDLE);
                COORD cursorPos = { posX, posY + i };
                SetConsoleCursorPosition(consoleHandle, cursorPos);
                cout << i + 1 << ". ";
                wcout << tempsavedtours.substr(0, tempsavedtours.find(L"\n"));
                tempsavedtours = tempsavedtours.erase(0, tempsavedtours.find(L"\n") + 1);
            }
            printCentered("Введите 1 для редактирования сохраненных туров, 0 для возвращения в главное меню\nОсуществите выбор: ", 2, posX, posY + count + 1);
            cin >> userchoice;
            if (userchoice == 1) {
                printCentered("                                                                                       ", 2, posX, posY + count + 1);
                printCentered("Введите 1 удаления выбранного тура, 0 для удаления всех\nОсуществите выбор: ", 2, posX, posY + count +1);
                cin >> userchoice;
                if (userchoice == 1) {
                    printCentered("                                                                   ", 2, posX, posY + count + 1);
                    printCentered("Введите номер тура, который хотите удалить\nОсуществите выбор: ", 2, posX, posY + count + 1);
                    cin >> userchoice;
                    if (userchoice >0 && userchoice<= count) {
                        deleteChoosenSavedTour(userchoice, userlogin);
                    }
                    else {
                        printCentered("Тура c таким номером нет", 1, 0, 0);
                    }
                }
                else if (userchoice == 0) {
                    deleteSavedTours(userlogin);
                }
                break;
            }
            else if (userchoice == 0) {
                break;
            }
            else {
                printCentered("Некорректный ввод. Повторите действие", 1, 0, 0);
            }
        }
    }
}

void deleteChoosenSavedTour(int tournum, string userlogin) {
    wifstream file("savedtour.txt", ios::app);
    file.imbue(locale(file.getloc(), new codecvt_utf8<wchar_t>));
    wstring line;
    int countoffounduserstours = 0;
    while (getline(file, line)) {
        if (line.substr(0, line.find(L":")) == stringToWstring(userlogin)) {
            countoffounduserstours++;
            if (countoffounduserstours == tournum) {
                Deleting(line, "savedtour.txt");
                printCentered("Тур успешно удален", 1, 0, 0);
                break;
            }
        }
    }
}

void Exit(User& currentUser) {
    string choice = "да";
    while (choice == "да")
    {
        printCentered("Вы уверены что желаете выйти из системы (да/нет): ", 1, 0, 0);
        cin >> choice;
        if (choice == "да") {
            currentUser.username = "";
            currentUser.password = "";
            printCentered("Вы вышли из учетной записи.", 1, 0, 0);
            break;
        }
        else if (choice != "да" && choice != "нет") {
            printCentered("Такого выбора не существует. Желаете повторить действие (да/нет):  ", 1, 0, 0);
            cin >> choice;
        }
    }
    Sleep(1000);
}

void ShowUsers(int choice) {
    system("cls");
    ifstream file("users.txt");
    if (!file.is_open()) {
        cout << "Файл не открыт";
    }
    int count = 1;
    string line, stingofusers = "ПОЛЬЗОВАТЕЛИ, ИМЕЮЩИЕСЯ В СИСТЕМЕ:\n";
    while (getline(file, line)) {

        stingofusers += to_string(count) + ". " + line.substr(0, line.find(' ')) + "\n";
        count++;
    }

    if (choice == 1) {
        stingofusers += "\n\nВведите логин пользователя, сохраненные туры которого вы хотите просмотреть: ";
    }
    else if (choice == 2) {
        stingofusers += "\n\nВведите логин пользователя, которого хотите удалить: ";
    }
    printCentered(stingofusers, count + 3, 0, 0);

}

bool isDateInRange(wstring startDate, wstring storedStartDate, wstring storedEndDate) {
    if (startDate != L"") {
        storedStartDate = storedStartDate.substr(6, 4) + storedStartDate.substr(3, 2) + storedStartDate.substr(0, 2);
        startDate = startDate.substr(6, 4) + startDate.substr(3, 2) + startDate.substr(0, 2);
        storedEndDate = storedEndDate.substr(6, 4) + storedEndDate.substr(3, 2) + storedEndDate.substr(0, 2);
        return (startDate >= storedStartDate && startDate <= storedEndDate);
    }
    else {
        return L" ";
    }
}

void split(const wstring& input, wstring& storedCityOfDeparture, wstring& storedCountryOfArrival,
    wstring& storedResortCity, wstring& storedStartDate, wstring& storedEndDate, wstring& storedMaxCost) {

    int currentIndex = 0;
    for (int i = 0; i < 6; ++i) {
        wstring substring;

        int nextIndex = input.find(L'/', currentIndex);

        if (nextIndex != -1) {
            substring = input.substr(currentIndex, nextIndex - currentIndex);
            currentIndex = nextIndex + 1;
        }
        else {
            substring = input.substr(currentIndex);
        }

        switch (i) {
        case 0:
            storedCityOfDeparture = substring;
            break;
        case 1:
            storedCountryOfArrival = substring;
            break;
        case 2:
            storedResortCity = substring;
            break;
        case 3:
            storedStartDate = substring;
            break;
        case 4:
            storedEndDate = substring;
            break;
        case 5:
            storedMaxCost = substring;
            break;
        default:
            break;
        }
    }

}

void getSearchCriteria(wstring& departureCity, wstring& arrivalCountry, wstring& resortCity, wstring& startDate, wstring& maxPrice) {
    getline(wcin, departureCity);
    printCentered("Город отправления (или нажмите Enter, если этот критерий поиска не важен): ", 1, 0, 0);
    getline(wcin, departureCity);
    for (int i = 0; i < departureCity.length(); i++) {
        departureCity[i]= tolower(departureCity[i], locale());
    }
    printCentered("Страна прибытия (или нажмите Enter, если этот критерий поиска не важен): ", 1, 0, 0);
    getline(wcin, arrivalCountry);
    for (int i = 0; i < arrivalCountry.length(); i++) {
        arrivalCountry[i] = tolower(arrivalCountry[i], locale());
    }
    printCentered("Курортный город (или нажмите Enter, если этот критерий поиска не важен): ", 1, 0, 0);
    getline(wcin, resortCity);
    for (int i = 0; i < resortCity.length(); i++) {
        resortCity[i] = tolower(resortCity[i], locale());
    }
    printCentered("Дата отправления в формате дд-мм-гггг (или нажмите Enter, если этот критерий поиска не важен): ", 1, 0, 0);
    getline(wcin, startDate);
    printCentered("Цена (или нажмите Enter, если этот критерий поиска не важен): ", 1, 0, 0);
    getline(wcin, maxPrice);
}

bool isTourMatchingCriteria(wstring& departureCity, wstring& arrivalCountry, wstring& resortCity, wstring& startDate, wstring& maxPrice, wstring& line) {
    wstring storedCityOfDeparture, storedCountryOfArrival, storedResortCity, storedStartDate, storedEndDate, storedMaxCost;
    split(line, storedCityOfDeparture, storedCountryOfArrival, storedResortCity, storedStartDate, storedEndDate, storedMaxCost);
    return ((departureCity == storedCityOfDeparture || departureCity == L"") &&
        (arrivalCountry == storedCountryOfArrival || arrivalCountry == L"") &&
        (resortCity == storedResortCity || resortCity == L"") &&
        (isDateInRange(startDate, storedStartDate, storedEndDate) || startDate == L"") &&
        (maxPrice == L"" || (stoi(maxPrice) >= stoi(storedMaxCost))));
}

void printFoundTours(wstring** lines, int lineCount, int& x, int& y, int ifcolor, int index) {

    CONSOLE_SCREEN_BUFFER_INFO csbi;
    GetConsoleScreenBufferInfo(GetStdHandle(STD_OUTPUT_HANDLE), &csbi);

    int consoleWidth = csbi.srWindow.Right - csbi.srWindow.Left + 1;
    int consoleHeight = csbi.srWindow.Bottom - csbi.srWindow.Top + 1;

    string criteria1 = "|   город   | страна |  город  |   первое  | последнее |стоимость|отель|рейтинг|  тип  |линия | тип | наличие |необходимость|    тип    |\n";
    string criteria2 = "|отправления|прибытия|курортный|отправление|отправление|         |     | отеля |питания|берега|пляжа|трансфера|    визы     |перемещения|\n";

    y = 1 + (consoleHeight - lineCount - 1) / 2;
    x = (consoleWidth - criteria1.length()) / 2;

    HANDLE consoleHandle = GetStdHandle(STD_OUTPUT_HANDLE);
    COORD cursorPos = { x, y };
    SetConsoleCursorPosition(consoleHandle, cursorPos);
    cout << criteria1;

    cursorPos.Y = y + 1; 
    SetConsoleCursorPosition(consoleHandle, cursorPos);
    cout << criteria2;


    int linelenght = 0;
    for (int i = 0; i < 15; i++) {
        linelenght += lines[0][i].length();
    }
    x = (consoleWidth - linelenght - 17) / 2;
    y+=3;
    for (int i = 0; i < lineCount; ++i) {
        HANDLE consoleHandle = GetStdHandle(STD_OUTPUT_HANDLE);
        COORD cursorPos = { x, y };
        SetConsoleCursorPosition(consoleHandle, cursorPos);
        bool islastmintour = isLastMinTour(i, lines, 1);
        wstring templinesi5;
        if (islastmintour) {
            SetConsoleTextAttribute(consoleHandle, FOREGROUND_RED | FOREGROUND_GREEN);
        }
        cout << i + 1 << ". ";
        for (int j = 0; lines[i][j] != L""; ++j) {
            if (ifcolor == 1 && index == j) {
                SetConsoleTextAttribute(consoleHandle, FOREGROUND_RED);
            }
            wcout << lines[i][j] << " ";
            if (islastmintour) {
                SetConsoleTextAttribute(consoleHandle, FOREGROUND_RED | FOREGROUND_GREEN);
            }
            else {
                SetConsoleTextAttribute(consoleHandle, FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE); 
            }
        }
        SetConsoleTextAttribute(consoleHandle, FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE);
        y++;
    }
}

void ifSort(wstring**& lines, int lineCount, int& userchoice) {

    string userchoicesort;
    int cresing;

    system("cls");
    while (true) {
        printCentered("Отсортировать можно по:\n1. Городу отправления\n2. Стране прибытия\n3. Курортному городу\n4. Цене поездки\n5. Количеству ночей в туре\n6. По названию отеля\n7. Рейтингу отеля\n8. Типу питания\n9. Линии пляжа\n10. Типу берега\n11. Наличию трансфера\n12. Наличию визы\n13. Типу перемещению\nВыберите критерий для сортировки: ", 15, 0, 0);
        cin >> userchoice;
        if (userchoice > 13 || userchoice < 0) {
            printCentered("Такого критерия для сортировки нет. Повторите действие", 1, 0, 0);
            Sleep(1000);
        }
        else {
            while (true) {
                if (userchoice==1) {
                    printCentered("Города отправления можно отсортировать от:\n1. A до Я\n2. Я до А\nВыберете действие: ", 4, 0, 0);
                } 
                else if (userchoice == 2) {
                    printCentered("Страны прибытия можно отсортировать от:\n1. A до Я\n2. Я до А\nВыберете действие: ", 4, 0, 0);
                }
                else if (userchoice == 3) {
                    printCentered("Курортные города можно отсортировать от:\n1. A до Я\n2. Я до А\nВыберете действие: ", 4, 0, 0);
                } 
                else if (userchoice == 6) {
                    printCentered("Название отлей можно отсортировать от:\n1. A до Z\n2. Z до А\nВыберете действие: ", 4, 0, 0);
                }
                else if (userchoice == 8) {
                    string str1 = "Тип питания можно отсортировать следующим образом :                                                                                                  \n";
                    string str2 = "1. | без питания | завтрак | полупансион | полный пансион | полупансион c напитками | полный пансион c напитками | все включено | ультра все включено |\n";
                    string str3 = "   |     ro      |   bb    |     fb      |       hb       |           fb+           |             hb+            |      ai      |         aui         |\n";
                    string str4="\n2. | ультра все включено | все включено | полный пансион c напитками | полный пансион | полупансион c напитками | полупансион | завтрак | без питания |\n";
                    string str5 = "   |          aui        |      ai      |             hb+            |       hb       |           fb+           |     fb      |   bb    |     ro      |\n";
                    printCentered(str1 + str2 + str3 + str4 + str5 + "Выберете действие: ", 7, 0, 0);
                }
                else if (userchoice == 10) {
                    printCentered("Тип берега можно отсортировать как:\n1. галька | каменистый | песчаный | собственный\n2. собственный | песчаный | каменистый | галька\nВыберете действие: ", 4, 0, 0);
                }
                else if (userchoice == 11) {
                    printCentered("Введите 1, если хотите, чтоб сначала были отображены туры, предоставляющие трансфер\n2 - если сначала должны быть показаны туры, не предоставляющие трансфер\nВыберете действие: ", 3, 0, 0);
                }
                else if (userchoice == 12) {
                    printCentered("По наличию визы туры могут быть отсортированы как:\n1. не нужна | нужна | по прилету \n2. по прилету | нужна | не нужна\nВыберете действие: ", 4, 0, 0);
                }
                else if (userchoice == 13) {
                    printCentered("По типу перемещения можно отсортировать: \n1. от A до Я\n2. от Я до А\nВыберете действие: ", 4, 0, 0);
                }
                else {
                    printCentered("Вы хотите отсортировать по убыванию или по возрастанию.\nВведите 1, если по возрастанию, 2 - по убыванию: ", 2, 0, 0);
                }
                cin >> cresing;
                if (cresing != 1 && cresing != 2) {
                    printCentered("Такого варианта нет. Произведите действия еще рвз: ", 1, 0, 0);
                    Sleep(2000);
                }
                else {
                    break;
                }
            }

            if (userchoice >= 4) {
                userchoice += 2;
            } 

            if (userchoice == 6 || userchoice == 7 || userchoice == 9) {
                quickSort(lines, 0, lineCount - 1, cresing, userchoice-1);                
            }
            else if (userchoice==10) {
                 
                wstring foodtypes;
                if (cresing == 1) {
                    foodtypes = L"ro/bb/fb/fb+/hb/hb+/ai/uai";
                }
                else {
                    foodtypes = L"uai/ai/hb+/hb/fb+/fb/bb/ro";
                }

                wstring foodtype = foodtypes.substr(0, foodtypes.find(L"/"));
                foodtypes = foodtypes.erase(0, foodtypes.find(L"/") + 1);
                int i = 0;

                while (i != lineCount) {
                    shakerSort(lines, i, lineCount, userchoice - 1, 1);
                    int index = binarySearch(lines, i, lineCount, foodtype);

                    if (index == -1) {
                        foodtype = foodtypes.substr(0, foodtypes.find(L"/"));
                        foodtypes = foodtypes.erase(0, foodtypes.find(L"/") + 1);
                    }
                    else {                       
                        swap(lines[index], lines[i]);
                        i++;                        
                    }
                }

            }
            else {
                shakerSort(lines, 0, lineCount, userchoice - 1, cresing);
            }
            system("cls");
            break;
        }
    }

}


int binarySearch(wstring** lines, int left, int lineCount, wstring foodtype) {
    int right = lineCount-1;

    while (left <= right) {
        int mid = left + (right - left) / 2;

        if (lines[mid][9] == foodtype) {
            return mid;
        }
        else if (lines[mid][9] < foodtype) {
            left = mid + 1;
        }
        else {
            right = mid - 1;
        }
        wstring line = lines[mid][9];
    }

    return -1; 
}


int partition(wstring** &lines, int low, int high, int cresing, int index) {
    int pivot = stoi(lines[high][index]);

    int i = low - 1;
    for (int j = low; j <= high - 1; j++) {
        if ((cresing == 1 && stoi(lines[j][index]) < pivot) || (cresing == 2 && stoi(lines[j][index]) > pivot)) {
            i++;
            swap(lines[i], lines[j]);
        }     
    }
    swap(lines[i + 1], lines[high]);
    return i+1;
}

void quickSort(wstring** &lines, int low, int high, int cresing, int index) {
    if (low < high) {
        int pi = partition(lines, low, high, cresing, index);
        quickSort(lines, low, pi - 1, cresing, index);
        quickSort(lines, pi + 1, high, cresing, index);
    }
}


void shakerSort(wstring**& lines, int start, int lineCount, int index, int cresing) {
    bool swapped = true;
    int end = lineCount - 1;
    while (swapped) {
        swapped = false;

        for (int i = start; i < end; ++i) {

            if ((cresing == 1 && lines[i][index] > lines[i + 1][index]) || (cresing == 2 && lines[i][index] < lines[i + 1][index])){
                swap(lines[i], lines[i + 1]);
            }
            swapped = true;
        }
        --end;

        if (!swapped) {
            break;
        };

        swapped = false;

        for (int i = end - 1; i >= start; --i) {
            if ((cresing == 1 && lines[i][index] > lines[i + 1][index]) || (cresing == 2 && lines[i][index] < lines[i + 1][index])){
                swap(lines[i], lines[i + 1]);
            }
            swapped = true;
        }
        ++start;
    }
}







/*



void shakerSort(wstring**& lines, int start, int lineCount, int index, int cresing) {
    bool swapped = true;
    int end = lineCount - 1;
    while (swapped) {
        swapped = false;

        for (int i = start; i < end; ++i) {
            bool isLastMinTouri = isLastMinTour(lines[i][4]),
                isLastMinTourii = isLastMinTour(lines[i + 1][4]);
            if (isLastMinTouri && index == 5 && isLastMinTourii) {
                if (cresing == 1 || stoi(lines[i][index]) - stoi(lines[i][index]) * 0.3 > stoi(lines[i + 1][index]) - stoi(lines[i + 1][index]) * 0.3 ||
                    cresing == 2 || stoi(lines[i][index]) - stoi(lines[i][index]) * 0.3 < stoi(lines[i + 1][index]) - stoi(lines[i + 1][index]) * 0.3) {
                    swap(lines[i], lines[i + 1]);
                    swapped = true;
                }
            }
            if (isLastMinTouri && index == 5 && !isLastMinTourii) {
                if (cresing == 1 && stoi(lines[i][index]) - stoi(lines[i][index]) * 0.3 > stoi(lines[i + 1][index]) ||
                    cresing == 2 && stoi(lines[i][index]) - stoi(lines[i][index]) * 0.3 < stoi(lines[i + 1][index])) {
                    swap(lines[i], lines[i + 1]);
                    swapped = true;
                }
            }

            if (!isLastMinTouri && index == 5 && isLastMinTourii) {
                if (cresing == 1 && stoi(lines[i][index]) > stoi(lines[i + 1][index]) - stoi(lines[i + 1][index]) * 0.3 ||
                    cresing == 2 && stoi(lines[i][index]) < stoi(lines[i + 1][index]) - stoi(lines[i + 1][index]) * 0.3) {
                    swap(lines[i], lines[i + 1]);
                    swapped = true;
                }
            }

            if (!isLastMinTouri && index == 5 && !isLastMinTourii) {
                if (cresing == 1 && stoi(lines[i][index]) > stoi(lines[i + 1][index]) ||
                    cresing == 2 && stoi(lines[i][index]) < stoi(lines[i + 1][index])){;
                    swapped = true;
                }
            }

        }
        --end;

        if (!swapped) {
            break;
        };

        swapped = false;

        for (int i = end - 1; i >= start; --i) {
            bool isLastMinTouri = isLastMinTour(lines[i][4]),
                isLastMinTourii = isLastMinTour(lines[i + 1][4]);
            if (isLastMinTouri && index == 5 && isLastMinTourii) {
                if (cresing == 1 || stoi(lines[i][index]) - stoi(lines[i][index]) * 0.3 > stoi(lines[i + 1][index]) - stoi(lines[i + 1][index]) * 0.3 ||
                    cresing == 2 || stoi(lines[i][index]) - stoi(lines[i][index]) * 0.3 < stoi(lines[i + 1][index]) - stoi(lines[i + 1][index]) * 0.3) {
                    swap(lines[i], lines[i + 1]);
                    swapped = true;
                }
            }
            if (isLastMinTouri && index == 5 && !isLastMinTourii) {
                if (cresing == 1 && stoi(lines[i][index]) - stoi(lines[i][index]) * 0.3 > stoi(lines[i + 1][index]) ||
                    cresing == 2 && stoi(lines[i][index]) - stoi(lines[i][index]) * 0.3 < stoi(lines[i + 1][index])) {
                    swap(lines[i], lines[i + 1]);
                    swapped = true;
                }
            }

            if (!isLastMinTouri && index == 5 && isLastMinTourii) {
                if (cresing == 1 && stoi(lines[i][index]) > stoi(lines[i + 1][index]) - stoi(lines[i + 1][index]) * 0.3 ||
                    cresing == 2 && stoi(lines[i][index]) < stoi(lines[i + 1][index]) - stoi(lines[i + 1][index]) * 0.3) {
                    swap(lines[i], lines[i + 1]);
                    swapped = true;
                }
            }

            if (!isLastMinTouri && index == 5 && !isLastMinTourii) {
                if (cresing == 1 && stoi(lines[i][index]) > stoi(lines[i + 1][index]) ||
                    cresing == 2 && stoi(lines[i][index]) < stoi(lines[i + 1][index])) {
                    swap(lines[i], lines[i + 1]);
                    swapped = true;
                }
            }
        }
        ++start;
    }
}










*/


void Findtours(wstring**& lines, int& lineCount, int choice) {
    system("cls");
    wifstream file("toursmain1.txt");
    file.imbue(locale(file.getloc(), new codecvt_utf8<wchar_t>));
    wstring departureCity, arrivalCountry, resortCity, startDate, maxPrice;
    if (choice == 1) {
        getSearchCriteria(departureCity, arrivalCountry, resortCity, startDate, maxPrice);
    }
    else {
        departureCity = L"";
        arrivalCountry = L"";
        resortCity = L"";
        startDate = L"";
        maxPrice = L"";
    }

    wstring line;
    while (getline(file, line)) {
        if (isTourMatchingCriteria(departureCity, arrivalCountry, resortCity, startDate, maxPrice, line)) {
            addFoundToursInArray(lines, lineCount, line);
        }
    }

    for (int i = 0; i < lineCount; i++) {
        isLastMinTour(i, lines, 0);
    }

    file.close();
}

bool isLastMinTour(int index, wstring**& lines, int role) {
    SYSTEMTIME t;
    GetLocalTime(&t);
    int day1 = stoi(lines[index][4].substr(0, 2)), 
        month1 = stoi(lines[index][4].substr(3, 2)), 
        year1 = stoi(lines[index][4].substr(6, 4));
    
    int day2 = t.wDay, month2 = t.wMonth, year2 = t.wYear;

    int diffYears = year2 - year1;
    int diffMonths = month2 - month1;
    int diffDays = day2 - day1;

    if (diffMonths < 0) {
        diffYears--;
        diffMonths += 12;
    }
    if (diffDays < 0) {
        if (month1 == 4 || month1 == 6 || month1 == 9 || month1 == 11)
            diffDays += 30;
        else if (month1 == 2) {
            // февраля
            if ((year1 % 4 == 0 && year1 % 100 != 0) || (year1 % 400 == 0))
                diffDays += 29; // високосный год
            else
                diffDays += 28; // обычный год
        }
        else
            diffDays += 31;
        diffMonths--;
    }

    int diffInDays = diffYears * 365 + diffMonths * 30 + diffDays;
    if (diffInDays < 0) {
        diffInDays *= -1;
    }

    if (diffInDays <= 5 && role == 0) {// именение масссива 
        lines[index][5] = (to_wstring(static_cast<int>(round(stod(lines[index][5]) - stod(lines[index][5]) * 0.3))));
    } 
    return (diffInDays <= 5);
}

void addFoundToursInArray(wstring**& lines, int& lineCount, const wstring& line) {
    if (!line.empty()) {
        wstring tempLine = line;
        wstring* substrings = new wstring[line.size()];
        int substringCount = 0;
        size_t pos = 0;
        while ((pos = tempLine.find(L"/")) != wstring::npos) {
            substrings[substringCount++] = tempLine.substr(0, pos);
            tempLine.erase(0, pos + 1);
        }
        substrings[substringCount++] = tempLine;
        wstring** temp = new wstring * [lineCount + 1];
        copy(lines, lines + lineCount, temp);
        delete[] lines;
        lines = temp;
        lines[lineCount++] = substrings;
    }

}

void FindToDeletIrrelevant() {
    wifstream file("toursmain1.txt");
    file.imbue(locale(file.getloc(), new codecvt_utf8<wchar_t>));
    printCentered("Введите желаемую дату (в формате дд-мм-гггг): ", 1, 0, 0);
    wstring today, line, storedEndDate;
    wcin >> today;
    today = today.substr(6, 4) + today.substr(3, 2) + today.substr(0, 2);
    int count = 0;
    while (getline(file, line)) {
        storedEndDate = splitEndDate(line);
        if (storedEndDate == L"") {
            printCentered("Хранимая дата окончания тура не получена", 1, 0, 0);
        }
        else
            if (storedEndDate <= today)
            {
                Deleting(line, "toursmain1.txt");
                deletingSaveToursAfterDeletingMainTour(line);
                count++;
            }
    }
    if (count == 0) {
        printCentered("Нет неактуальных туров", 1, 0, 0);
    }
    else {
        printCentered("Успешно удалено " + to_string(count) + " туров", 1, 0, 0);
    }

}

wstring splitEndDate(const wstring line) {
    int count = 0, startPos = 0, endPos = 0;

    for (int i = 0; i < line.length(); ++i) {
        if (line[i] == L'/') {
            count++;
            if (count == 4) {
                startPos = i + 1;
                break;
            }
        }
    }

    if (count == 0) {
        return L"";
    }
    else {
        return (line.substr(startPos, 10)).substr(6, 4) + (line.substr(startPos, 10)).substr(3, 2) + (line.substr(startPos, 10)).substr(0, 2);
    }
}

void DeleteChoosenUser(int role, string userlogin) { // удалять все сохраненные туры удаляемого пользователя
    system("cls");
    wifstream file("users.txt");
    wstring login, line;
    if (role == 0) {
        ShowUsers(2);
        wcin >> login;
        if (!isUsernameUnique("users.txt", wstringToString(login)))
        {
            while (getline(file, line)) {
                if (login == line.substr(0, line.find(' '))) {
                    Deleting(line, "users.txt");
                    printCentered("Пользователь " + wstringToString(login) + " успешно удален", 1, 0, 0); //переделать так "Пользователь" + login + "успешно удален"
                    Sleep(2000);
                }
            }
        }
        else {
            printCentered("Пользователя " + wstringToString(login) + " нет в системе", 1, 0, 0); //переделать так "Пользователь" + login + "успешно удален"
            Sleep(2000);
        }
    }
    else {
        printCentered("Вы уверены, что желаете удалить учетную запись (да/нет): ", 1, 0, 0);
        wstring choice;
        wcin >> choice;
        while (true) {
            if (choice == L"да") {
                while (getline(file, line)) {
                    if ((stringToWstring(userlogin)) == line.substr(0, line.find(' '))) {
                        Deleting(line, "users.txt");
                        printCentered("Пользователь успешно удален", 1, 0, 0); //переделать так "Пользователь" + login + "успешно удален"
                        Sleep(2000);
                    }
                }

            }
            else if (choice == L"нет") {
                break;
            }
            else if (choice != L"да" && choice != L"нет") {
                printCentered("Такого варианта нет. Повторите попытку", 1, 0, 0);
                Sleep(3000);
                printCentered("Вы уверены, что желаете удалить учетную запись (да/нет): ", 1, 0, 0);
                wcin >> choice;
            }
        }
    }
    deleteSavedTours(wstringToString(login));
}

wstring stringToWstring(const string& str) {
    wstring_convert<codecvt_utf8_utf16<wchar_t>> converter;
    return converter.from_bytes(str);
}

string wstringToString(const wstring& wstr) {
    wstring_convert<codecvt_utf8_utf16<wchar_t>> converter;
    return converter.to_bytes(wstr);
}

void DeleteChoosenByCriteriaTour() {
    system("cls");
    wifstream file("toursmain1.txt");
    file.imbue(locale(file.getloc(), new codecvt_utf8<wchar_t>));
    wstring departureCity, arrivalCountry, resortCity, startDate, maxPrice, line;
    getSearchCriteria(departureCity, arrivalCountry, resortCity, startDate, maxPrice);
    int count = 0;
    while (getline(file, line)) {
        if (isTourMatchingCriteria(departureCity, arrivalCountry, resortCity, startDate, maxPrice, line)) {
            Deleting(line, "toursmain1.txt");
            deletingSaveToursAfterDeletingMainTour(line);
            count++;
        }
    }

    printCentered("Успешно удалено " + to_string(count) + " туров", 1, 0, 0);
    file.close();
}

void deletingSaveToursAfterDeletingMainTour(wstring deletingtour) {
    wifstream file("savedtour.txt", ios:: app);
    file.imbue(locale(file.getloc(), new codecvt_utf8<wchar_t>));
    wstring line;
    while (getline(file, line)) {
        wstring templine = line.substr(line.find(L":")+2, line.length()); 
        if (templine == deletingtour) {
            Deleting(line, "savedtour.txt");
        }
    }
}

void Deleting(const wstring& lineToDelete, const string filename) {
    wifstream fileIn(filename);
    fileIn.imbue(locale(fileIn.getloc(), new codecvt_utf8<wchar_t>));
    wstring line;
    wstring fileContent;
    if (!fileIn.is_open()) {
        cerr << L"Ошибка открытия файла" << endl;
    }
    else {

        while (getline(fileIn, line)) {
            if (line != lineToDelete) {
                fileContent += line + L"\n";
            }
        }
        fileIn.close();
    }
    wofstream fileOut(filename);
    fileOut.imbue(locale(fileOut.getloc(), new codecvt_utf8<wchar_t>));
    if (!fileOut.is_open()) {
        cerr << L"Ошибка открытия файла для записи" << endl;
        return;
    }
    else {
        fileOut << fileContent;
        fileOut.close();
    }
}

void changeAccountData(const string filename, const string userlogin, const string userpassword, int field, User& currentUser) {// field = 1 изменение логина field = 2 изменение пароля 
    system("cls");
    ifstream file(filename);
    if (!file.is_open()) {
        cerr << "Ошибка открытия файла!" << endl;
        exit(1);
    }
    else {
        string newfield, line;
        if (field == 1) {
            printCentered("Введите новый логин: ", 1, 0, 0);
            cin >> newfield;
            while (getline(file, line)) {
                if (line == userlogin + " " + userpassword) {
                    Deleting(stringToWstring(line), filename);
                }
            }

            while (!isUsernameUnique(filename, newfield)) {
                printCentered("Пользователь с таким логином уже существует. Пожалуйста, выберите другой логин.", 1, 0, 0);
                Sleep(2000);
                printCentered("Введите новый логин: ", 1, 0, 0);
                cin >> newfield;
            }

            //функция добавления нового пользователя которая у админа. передать новый логин и пароль из структуры userpassword
            addNewData("users.txt", (newfield + " " + currentUser.password));
            currentUser.username = newfield;
            printCentered("Ваши данные успешно изменены.", 1, 0, 0);
            editSavedTours(userlogin, newfield);
        }
        else { // зациклить до трях попыток пока два пароля не будут одинаковыми
            while (true) {
                printCentered("Введите новый пароль: ", 1, 0, 0);
                cin >> newfield;
                while (getline(file, line)) {
                    if (line == userlogin + " " + userpassword) {
                        Deleting(stringToWstring(line), filename);
                    }
                }

                string password;
                printCentered("Введите повторно новый пароль: ", 1, 0, 0);
                cin >> password;

                if (password == newfield) {
                    //функция добавления нового пользователя которая у админа. передать логин из структуры userlogin и новый пароль
                    addNewData("users.txt", (currentUser.username + " " + newfield));
                    currentUser.password = newfield;
                    printCentered("Ваши данные успешно изменены.", 1, 0, 0);
                    break;
                }
                else {
                    printCentered("Пароли отличаются. Попробуйте еще раз.", 1, 0, 0);
                    Sleep(1000);
                }
            }
        }
    }
}

void editSavedTours(string olduserlogin, string newuserlogin) {
    wifstream file("savedtour.txt");
    file.imbue(locale(file.getloc(), new codecvt_utf8<wchar_t>));
    wstring line, linesofsavedtours;
    while (getline(file, line)) {
        if (line.substr(0, line.find(L":")) == stringToWstring(olduserlogin)) {
            linesofsavedtours += stringToWstring(newuserlogin) + line.substr(line.find(L":"), line.length() - line.find(L":")) + L"\n";
            Deleting(line, "savedtour.txt");
        }
    }
    addNewTour("savedtour.txt", linesofsavedtours);
}


void editTours(wstring**& lines, int lineCount, string filename, int choice) {
    int count = 0, pos = 0, endpos = 0, startpos = 0;
    while (choice > lineCount || choice <= 0) {
        printCentered("Тура с таким номером не существует. Введите корректно: ", 1, 0, 0);
        cin >> choice;
    }
    wstring editedtour, line, newfield;
    for (int i = 0;i < 15; i++) {
        editedtour += lines[choice - 1][i] + L"/";
    }
    wifstream file(filename);
    file.imbue(locale(file.getloc(), new codecvt_utf8<wchar_t>));
    while (getline(file, line)) {
        if (line == editedtour) {
            printCentered("ПОЛЯ ДЛЯ РЕДАКТИРОВАНИЯ\n1. Город отправления\n2. Страна прибытия\n3. Курортный город\n4. Начало продаж тура\n5. Окончание продаж тура\n6. Цена\n7. Количестро ночей\n8. Название отеля\n9. Рейтинг отеля\n10. Тип питания\n11. Линия пляжа\n12. Тип пляжа\n13. Наличие трансфера\n14. Необходимость визы\n15. Тип перемещения\nВыберите изменяемое поле: ", 17, 0, 0);
            cin >> choice;
            printCentered("Введите новую информацию о туре: ", 1, 0, 0);
            getline(wcin, newfield);
            getline(wcin, newfield);
            for (int i = 0; i < line.length(); ++i) {
                pos++;
                if (line[i] == L'/') {
                    count++;
                    if (count == choice) {
                        startpos = pos;
                    }
                    if (count == choice + 1) {
                        endpos = pos;
                        break;
                    }
                }
            }

        }
    }

    Deleting(editedtour, "toursmain1.txt");
    addNewTour(filename, editedtour.substr(0, startpos) + newfield + editedtour.substr(endpos - 1, editedtour.length() - startpos));
    printCentered("Тур успешно изменен.", 1, 0, 0);
}

string getFieldsOfNewUser() {
    string loginofnewuser, passwordofnewuser;
    printCentered("Введите логин, добавляемого пользователя: ", 1, 0, 0);
    cin >> loginofnewuser;
    while (!isUsernameUnique("users.txt", loginofnewuser)) {
        printCentered("Пользователь с таким логином уже существует. Пожалуйста, выберите другой логин.\nВведите логин добавляемого пользователя: ", 1, 0, 0);
        cin >> loginofnewuser;
    }
    printCentered("Введите пароль, добавляемого пользователя: ", 1, 0, 0);
    cin >> passwordofnewuser;
    return (loginofnewuser + " " + passwordofnewuser);
}

void addNewData(const string filename, string addedline) {
    ofstream file(filename, ios::app);

    if (!file.is_open()) {
        cerr << "Ошибка открытия файла!" << endl;
        exit(1);
    }
    else {
        file << addedline << endl;
    }
}

void addNewTour(const string filename, wstring addedline) {
    wofstream file(filename, ios::app);
    file.imbue(locale(file.getloc(), new codecvt_utf8<wchar_t>));
    if (!file.is_open()) {
        wcerr << "Ошибка открытия файла!" << endl;
        exit(1);
    }
    else {
        for (int i = 0; i < addedline.length(); i++) {
            addedline[i] = tolower(addedline[i], locale());
        }
        file << addedline;
    }
}

wstring getFieldsOfNewTour() {
    wstring data, input, start;
    string choicecontinue = "да", choiceadd;
    ;
    int countofadd = 0;
    CONSOLE_SCREEN_BUFFER_INFO csbi;
    GetConsoleScreenBufferInfo(GetStdHandle(STD_OUTPUT_HANDLE), &csbi);

    int consoleWidth = csbi.srWindow.Right - csbi.srWindow.Left + 1;
    int consoleHeight = csbi.srWindow.Bottom - csbi.srWindow.Top + 1;
    while (choicecontinue == "да") {
        for (int i = 1; i < 16; i++) {
            switch (i)
            {
            case 1:
                getline(wcin, data);
                printCentered("Введите город отправления: ", 1, 0, 0);
                getline(wcin, data);
                while (data.empty()) {
                    printCentered("Город отправления введен неверно.\nВведите заново: ", 2, 0, 0);
                    getline(wcin, data);
                }
                break;
            case 2:
                printCentered("Введите страну прибытия: ", 1, 0, 0);
                getline(wcin, data);
                while (data.empty()) {
                    printCentered("Страну прибытия введен неверно.\nВведите заново: ", 2, 0, 0);
                    getline(wcin, data);
                }
                break;
            case 3:
                printCentered("Введите курортный город: ", 1, 0, 0);
                getline(wcin, data);
                while (data.empty()) {
                    printCentered("Курортный город введен неверно.\nВведите заново: ", 2, 0, 0);
                    getline(wcin, data);
                }
                break;
            case 4:
                printCentered("Введите дату первого отправления в формате дд.мм.гггг: ", 1, 0, 0); 
                getline(wcin, data);
                while (true) {
                    start = data;
                    for (char c : data.substr(0, 2)) {
                        if (!isdigit(c)) {
                            printCentered("Дата не может содержать буквы или символы.\nВведите заново: ", 2, 0, 0);
                            getline(wcin, data);
                            break;
                        }
                    }
                    for (char c : data.substr(3, 2)) {
                        if (!isdigit(c)) {
                            printCentered("Дата не может содержать буквы или символы.\nВведите заново: ", 2, 0, 0);
                            getline(wcin, data);
                            break;
                        }
                    }
                    for (char c : data.substr(6, 4)) {
                        if (!isdigit(c)) {
                            printCentered("Дата не может содержать буквы или символы.\nВведите заново: ", 2, 0, 0);
                            getline(wcin, data);
                            break;
                        }
                    }
                    if (data.length() != 10) {
                        printCentered("Дата имеет неверный формат.\nВведите заново: ", 2, 0, 0);
                        getline(wcin, data);
                    }                    
                    else if (stoi(data.substr(0, 2)) <= 0 && stoi(data.substr(3, 2)) <= 0 && stoi(data.substr(6, 4)) <= 0) {
                        printCentered("Дата первого отправления введена неверно.\nВведите заново: ", 2, 0, 0);
                        getline(wcin, data);
                    }
                    else {
                        break;
                    }                            
                }
                break;
            case 5:
                printCentered("Введите дату последнего отправления в формате дд.мм.гггг: ", 1, 0, 0);
                getline(wcin, data);
                while (true) {                   
                    for (char c : data.substr(0,2)) {
                        if (!isdigit(c)) {
                            printCentered("Дата не может содержать буквы или символы.\nВведите заново: ", 2, 0, 0);
                            getline(wcin, data);
                            break;
                        }
                    }
                    for (char c : data.substr(3, 2)) {
                        if (!isdigit(c)) {
                            printCentered("Дата не может содержать буквы или символы.\nВведите заново: ", 2, 0, 0);
                            getline(wcin, data);
                            break;
                        }
                    }
                    for (char c : data.substr(6, 4)) {
                        if (!isdigit(c)) {
                            printCentered("Дата не может содержать буквы или символы.\nВведите заново: ", 2, 0, 0);
                            getline(wcin, data);
                            break;
                        }
                    }
                    if (data.length() != 10) {
                        printCentered("Дата имеет неверный формат.\nВведите заново: ", 2, 0, 0);
                        getline(wcin, data);
                    } else 
                    if ((data.substr(6, 4) + data.substr(3, 2) + data.substr(0, 2)) <= (start.substr(6, 4) + start.substr(3, 2) + start.substr(0, 2))) {
                        printCentered("Дата последнего отправления не может совпадать или быть позже первого отправления.\nВведите дату последнего отправления заново: ", 2, 0, 0);
                        getline(wcin, data);
                    } else 
                    if (stoi(data.substr(0, 2)) <= 0 && stoi(data.substr(3, 2)) <= 0 && stoi(data.substr(6, 4)) <= 0) {
                        printCentered("Дата последнего отправления введена неверно.\nВведите заново: ", 2, 0, 0);
                        getline(wcin, data);
                    }
                    else {
                        break;
                    }
                }
                break;
            case 6:
                printCentered("Введите цену: ", 1, 0, 0);
                getline(wcin, data);
                while (true) {
                    for (char c : data) {
                        if (!isdigit(c)) {
                            printCentered("Цена не может содержать буквы или символы.\nВведите заново: ", 2, 0, 0);
                            getline(wcin, data);
                            break;
                        }
                    }
                    if (stoi(data) <= 0) {
                        printCentered("Цена введена неверно.\nВведите заново: ", 2, 0, 0);
                        getline(wcin, data);
                    }
                    else {
                        break;
                    }
                }
                break;
            case 7:
                printCentered("Введите количество ночей: ", 1, 0, 0); 
                getline(wcin, data);
                while (true) {
                    for (char c : data) {
                        if (!isdigit(c)) {
                            printCentered("Цена не может содержать буквы или символы.\nВведите заново: ", 2, 0, 0);
                            getline(wcin, data);
                            break;
                        }
                    }
                    if (stoi(data) <= 0) {
                        printCentered("Количество ночей введено неверно.\nВведите заново: ", 2, 0, 0);
                        getline(wcin, data);
                    }
                    else {
                        break;
                    }
                }
                break;
            case 8:
                printCentered("Введите название отеля: ", 1, 0, 0);
                getline(wcin, data);
                while (data.empty()) {
                    printCentered("Название отеля введено неверно.\nВведите заново: ", 2, 0, 0);
                    getline(wcin, data);
                }
                break;
            case 9:
                printCentered("Введите рейтинг отеля: ", 1, 0, 0);// проверять на цифры
                getline(wcin, data);
                while (true) {
                    for (char c : data) {
                        if (!isdigit(c)) {
                            printCentered("Рейтинг отеля не может содержать буквы или символы.\nВведите заново: ", 2, 0, 0);
                            getline(wcin, data);
                            break;
                        }
                    }
                    if (stoi(data) <= 0 || stoi(data) > 5) {
                        printCentered("Рейтинг отеля введен неверно.\nВведите заново: ", 2, 0, 0);
                        getline(wcin, data);
                    }
                    else {
                        break;
                    }
                }
                break;
            case 10:
                printCentered("Типы питания\nRO - без питания\nBB - завтраки\nHB - полупансион(завтрак и ужин)\nFB - полный пансион(завтрак, обед и ужин)\nHB+ - полупансион с напитками\nFB+ - полный пансион с напитками\nAI - все включено \nUAI - ультра все включено\nВведите тип питания: ", 10, 0, 0);
                getline(wcin, data);
                for (int i = 0; i < data.length(); i++) {
                    data[i] = tolower(data[i], locale());
                }
                while (data != L"ro" && data != L"bb" && data != L"hb" && data != L"fb" && data != L"hb+" && data != L"fb+" && data != L"ai" && data != L"uai" ) {
                    printCentered("Тип питания введен неверно.\nВведите заново (BB, HB, FB, HB+, FB+, AI, UAI): ", 2, 0, 0);
                    getline(wcin, data);
                }
                break;
            case 11:
                printCentered("Линии пляжа\nЕсли до моря < 100 м, то линия пляжа первая\nЕсли до моря < 200 м, то линия пляжа вторая\nЕсли до моря > 300 м, то линия пляжа третья\nОсуществите ввод(1, 2 или 3): ", 5, 0, 0);
                getline(wcin, data);
                while (stoi(data) != 1 && stoi(data) != 2 && stoi(data) != 3) {
                    printCentered("Линия пляжа введена неверно.\nВведите заново (1, 2 или 3): ", 2, 0, 0);
                    getline(wcin, data);
                }
                break;
            case 12:
                printCentered("Введите тип берега: ", 1, 0, 0);
                getline(wcin, data);
                while (data.empty()) {
                    printCentered("Тип берега введен неверно.\nВведите заново: ", 2, 0, 0);
                    getline(wcin, data);
                }
                break;
            case 13:
                printCentered("Введите наличие трансфера(есть/нет): ", 1, 0, 0);
                getline(wcin, data);
                while (data != L"есть" && data != L"нет") {
                    printCentered("Наличие трансфера введено неверно.\nВведите заново наличие трансфера(есть/нет): ", 2, 0, 0);
                    getline(wcin, data);
                }
                break;
            case 14:
                printCentered("Введите необходимость в наличии визы(нужна/не нужна/по прилету): ", 1, 0, 0);
                getline(wcin, data);
                while (data != L"нужна" && data != L"не нужна" && data != L"по прилету") {
                    printCentered("Необходимость в наличии визы введена неверно.\nВведите заново (нужна/не нужна/по прилету): ", 2, 0, 0);
                    getline(wcin, data);
                }
                break;
            case 15:
                printCentered("Введите тип перемещения: ", 1, 0, 0);
                getline(wcin, data);
                while (data.empty()) {
                    printCentered("Тип перемещения введен неверно.\nВведите заново: ", 2, 0, 0);
                    getline(wcin, data);
                }
                break;
            default:
                break;
            }
            input += data + L"/";
        }

        wstring test = input + L"\n";
        system("cls");

        int posY = (consoleHeight - countofadd + 1) / 2;
        int posX = 0;
        for (int i = 0; i <= countofadd; i++) {
            posX = (consoleWidth - (test.substr(0, test.find(L'\n'))).length()) / 2;
            COORD cursorPos = { posX, posY };
            SetConsoleCursorPosition(GetStdHandle(STD_OUTPUT_HANDLE), cursorPos);

            wcout << test.substr(0, test.find(L'\n'));
            test = test.substr(test.find(L'\n') + 1);
            posY++;
            if (i == countofadd) {

                const string d = "Вы уверены, что хотите добавить последний введенный тур (да/нет): ";
                posX = (consoleWidth - d.length()) / 2;
                COORD cursorPos = { posX, posY };
                SetConsoleCursorPosition(GetStdHandle(STD_OUTPUT_HANDLE), cursorPos);
                cout << d;
            }
        }

        cin >> choiceadd;
        printCentered("Желаете добавить еще (да/нет): ", 1, 0, 0);
        cin >> choicecontinue;

        if (choiceadd == "нет" && choicecontinue == "нет") {
            input = L"";
            break;
        }
        else if (choiceadd == "нет" && choicecontinue == "да") {
            if (countofadd == 0) {
                input = L"";
            }
            else {
                input = input.substr(0, input.find_last_of(L"\n") + 1);
            }

        } if (choiceadd == "да" && choicecontinue == "да") {
            input += L"\n";
            countofadd++;
        }

    }
    return L"\n" + input;
}
